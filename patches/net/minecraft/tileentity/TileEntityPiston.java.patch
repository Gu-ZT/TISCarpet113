--- a/net/minecraft/tileentity/TileEntityPiston.java
+++ b/net/minecraft/tileentity/TileEntityPiston.java
@@ -1,9 +1,13 @@
 package net.minecraft.tileentity;
 
 import java.util.List;
+import java.util.Optional;
+
+import carpet.settings.CarpetSettings;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockPistonBase;
 import net.minecraft.block.BlockPistonExtension;
+import net.minecraft.block.ITileEntityProvider;
 import net.minecraft.block.material.EnumPushReaction;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.entity.Entity;
@@ -29,6 +33,8 @@
     private EnumFacing pistonFacing;
     private boolean extending;
     private boolean shouldHeadBeRendered;
+    // [CM] Movable TE's - new var
+    private TileEntity carriedTileEntity;
     private static final ThreadLocal<EnumFacing> MOVING_ENTITY = new ThreadLocal<EnumFacing>()
     {
         protected EnumFacing initialValue()
@@ -40,6 +46,9 @@
     private float lastProgress;
     private long lastTicked;
 
+    // Cache BoundingBoxList creation
+    private Optional<List<AxisAlignedBB>> voxelShapeBoundingBoxList;
+
     public TileEntityPiston()
     {
         super(TileEntityType.PISTON);
@@ -52,6 +61,9 @@
         this.pistonFacing = pistonFacingIn;
         this.extending = extendingIn;
         this.shouldHeadBeRendered = shouldHeadBeRenderedIn;
+
+        // Cache BoundingBoxList creation
+        this.createVoxelShapeBoundingBoxListCache();
     }
 
     public NBTTagCompound getUpdateTag()
@@ -112,15 +124,21 @@
         return !this.isExtending() && this.shouldPistonHeadBeRendered() ? Blocks.PISTON_HEAD.getDefaultState().with(BlockPistonExtension.TYPE, this.pistonState.getBlock() == Blocks.STICKY_PISTON ? PistonType.STICKY : PistonType.DEFAULT).with(BlockPistonExtension.FACING, this.pistonState.get(BlockPistonBase.FACING)) : this.pistonState;
     }
 
+    private void createVoxelShapeBoundingBoxListCache()
+    {
+        VoxelShape voxelshape = this.getCollisionRelatedBlockState().getCollisionShape(this.world, this.getPos());
+        this.voxelShapeBoundingBoxList = !voxelshape.isEmpty() ? Optional.of(voxelshape.toBoundingBoxList()) : Optional.empty();
+    }
+
     private void moveCollidedEntities(float p_184322_1_)
     {
         EnumFacing enumfacing = this.getMotionDirection();
         double d0 = (double)(p_184322_1_ - this.progress);
-        VoxelShape voxelshape = this.getCollisionRelatedBlockState().getCollisionShape(this.world, this.getPos());
 
-        if (!voxelshape.isEmpty())
+        // Cache BoundingBoxList creation
+        if (this.voxelShapeBoundingBoxList.isPresent())
         {
-            List<AxisAlignedBB> list = voxelshape.toBoundingBoxList();
+            List<AxisAlignedBB> list = this.voxelShapeBoundingBoxList.get();
             AxisAlignedBB axisalignedbb = this.moveByPositionAndProgress(this.getMinMaxPiecesAABB(list));
             List<Entity> list1 = this.world.getEntitiesWithinAABBExcludingEntity((Entity)null, this.getMovementArea(axisalignedbb, enumfacing, d0).union(axisalignedbb));
 
@@ -178,6 +196,13 @@
                             {
                                 this.fixEntityWithinPistonBase(entity, enumfacing, d0);
                             }
+
+                            // [CM] Added UnloadedEntityFix
+                            if (CarpetSettings.unloadedEntityFix)
+                            {
+                                world.tickEntity(entity, false);
+                            }
+                            // [CM] End
                         }
                     }
                 }
@@ -318,10 +343,26 @@
                 {
                     iblockstate = Block.getValidBlockForPosition(this.pistonState, this.world, this.pos);
                 }
-
-                this.world.setBlockState(this.pos, iblockstate, 3);
-                this.world.neighborChanged(this.pos, iblockstate.getBlock(), this.pos);
+    
+                // [CM] Movable TE's CARPET-DeadlyMC
+                if (!CarpetSettings.movableTileEntities)
+                {
+                    this.world.setBlockState(this.pos, iblockstate, 3);
+                    this.world.neighborChanged(this.pos, iblockstate.getBlock(), this.pos);
+                }
+                else
+                {
+                    this.placeBlock();
+                }
             }
+            // [CM] Movable TE's CARPET-DeadlyMC
+            else if (CarpetSettings.movableTileEntities)
+            {
+                if (this.carriedTileEntity != null && this.world.getBlockState(this.pos).getBlock() == Blocks.AIR) {
+                    this.placeBlock();
+                    this.world.removeBlock(this.pos);
+                }
+            }
         }
     }
 
@@ -351,8 +392,15 @@
                         iblockstate = iblockstate.with(BlockStateProperties.WATERLOGGED, Boolean.valueOf(false));
                     }
 
-                    this.world.setBlockState(this.pos, iblockstate, 67);
-                    this.world.neighborChanged(this.pos, iblockstate.getBlock(), this.pos);
+                    if (!CarpetSettings.movableTileEntities)
+                    {
+                        this.world.setBlockState(this.pos, iblockstate, 67);
+                        this.world.neighborChanged(this.pos, iblockstate.getBlock(), this.pos);
+                    }
+                    else
+                    {
+                        this.placeBlock();
+                    }
                 }
             }
         }
@@ -378,6 +426,18 @@
         this.lastProgress = this.progress;
         this.extending = compound.getBoolean("extending");
         this.shouldHeadBeRendered = compound.getBoolean("source");
+    
+        // [CM] Movable TE's CARPET-DeadlyMC
+        if(CarpetSettings.movableTileEntities && compound.contains("carriedTileEntityCM", 10))
+        {
+            if(this.pistonState.getBlock() instanceof ITileEntityProvider)
+                this.carriedTileEntity = ((ITileEntityProvider)(this.pistonState.getBlock())).createNewTileEntity(this.world);
+            if(carriedTileEntity != null) // Can actually be null, as BlockPistonMoving.createNewTileEntity(...) returns null
+                this.carriedTileEntity.read(compound.getCompound("carriedTileEntityCM"));
+        }
+
+        // Cache BoundingBoxList creation
+        this.createVoxelShapeBoundingBoxListCache();
     }
 
     public NBTTagCompound write(NBTTagCompound compound)
@@ -388,6 +448,13 @@
         compound.putFloat("progress", this.lastProgress);
         compound.putBoolean("extending", this.extending);
         compound.putBoolean("source", this.shouldHeadBeRendered);
+    
+        // [CM] Movable TE's CARPET-DeadlyMC
+        if(CarpetSettings.movableTileEntities && this.carriedTileEntity != null)
+        {
+            compound.put("carriedTileEntityCM", this.carriedTileEntity.write(new NBTTagCompound()));
+        }
+        
         return compound;
     }
 
@@ -435,4 +502,37 @@
     {
         return this.lastTicked;
     }
+    
+    // [CM] Movable TE's - helper method
+    public void setCarriedTileEntity(TileEntity tileEntity)
+    {
+        this.carriedTileEntity = tileEntity;
+    }
+    
+    // [CM] Movable TE's - helper method
+    private void placeBlock()
+    {
+        this.world.setBlockState(this.pos, this.pistonState, 18); //Flag 18 => No block updates, TileEntity has to be placed first
+        
+        if(!this.world.isRemote)
+        {
+            if(carriedTileEntity != null)
+            {
+                this.world.removeTileEntity(this.pos);
+                carriedTileEntity.validate();
+                this.world.setTileEntity(this.pos, carriedTileEntity);
+            }
+            
+            //Update neighbors, comparators and observers now (same order as setBlockState would have if flag was set to 3 (default))
+            //This should not change piston behavior for vanilla-pushable blocks at all
+            
+            this.world.notifyNeighbors(pos, Blocks.MOVING_PISTON);
+            if (this.pistonState.hasComparatorInputOverride())
+            {
+                this.world.updateComparatorOutputLevel(pos, this.pistonState.getBlock());
+            }
+            this.world.notifyNeighborsOfStateChange(pos, this.pistonState.getBlock());
+        }
+        this.world.neighborChanged(this.pos, this.pistonState.getBlock(), this.pos);
+    }
 }
