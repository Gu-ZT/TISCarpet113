--- a/net/minecraft/tileentity/TileEntityPiston.java
+++ b/net/minecraft/tileentity/TileEntityPiston.java
@@ -1,9 +1,14 @@
 package net.minecraft.tileentity;
 
 import java.util.List;
+import java.util.Optional;
+
+import carpet.helpers.CreativeNoClipHelper;
+import carpet.settings.CarpetSettings;
 import net.minecraft.block.Block;
 import net.minecraft.block.BlockPistonBase;
 import net.minecraft.block.BlockPistonExtension;
+import net.minecraft.block.ITileEntityProvider;
 import net.minecraft.block.material.EnumPushReaction;
 import net.minecraft.block.state.IBlockState;
 import net.minecraft.entity.Entity;
@@ -29,6 +34,8 @@
     private EnumFacing pistonFacing;
     private boolean extending;
     private boolean shouldHeadBeRendered;
+    // [CM] Movable TE's - new var
+    private TileEntity carriedTileEntity;
     private static final ThreadLocal<EnumFacing> MOVING_ENTITY = new ThreadLocal<EnumFacing>()
     {
         protected EnumFacing initialValue()
@@ -40,6 +47,9 @@
     private float lastProgress;
     private long lastTicked;
 
+    // Cache BoundingBoxList creation
+    private Optional<List<AxisAlignedBB>> voxelShapeBoundingBoxList;
+
     public TileEntityPiston()
     {
         super(TileEntityType.PISTON);
@@ -52,6 +62,9 @@
         this.pistonFacing = pistonFacingIn;
         this.extending = extendingIn;
         this.shouldHeadBeRendered = shouldHeadBeRenderedIn;
+
+        // Cache BoundingBoxList creation
+        this.createVoxelShapeBoundingBoxListCache();
     }
 
     public NBTTagCompound getUpdateTag()
@@ -112,15 +125,21 @@
         return !this.isExtending() && this.shouldPistonHeadBeRendered() ? Blocks.PISTON_HEAD.getDefaultState().with(BlockPistonExtension.TYPE, this.pistonState.getBlock() == Blocks.STICKY_PISTON ? PistonType.STICKY : PistonType.DEFAULT).with(BlockPistonExtension.FACING, this.pistonState.get(BlockPistonBase.FACING)) : this.pistonState;
     }
 
+    private void createVoxelShapeBoundingBoxListCache()
+    {
+        VoxelShape voxelshape = this.getCollisionRelatedBlockState().getCollisionShape(this.world, this.getPos());
+        this.voxelShapeBoundingBoxList = !voxelshape.isEmpty() ? Optional.of(voxelshape.toBoundingBoxList()) : Optional.empty();
+    }
+
     private void moveCollidedEntities(float p_184322_1_)
     {
         EnumFacing enumfacing = this.getMotionDirection();
         double d0 = (double)(p_184322_1_ - this.progress);
-        VoxelShape voxelshape = this.getCollisionRelatedBlockState().getCollisionShape(this.world, this.getPos());
 
-        if (!voxelshape.isEmpty())
+        // Cache BoundingBoxList creation
+        if (this.voxelShapeBoundingBoxList.isPresent())
         {
-            List<AxisAlignedBB> list = voxelshape.toBoundingBoxList();
+            List<AxisAlignedBB> list = this.voxelShapeBoundingBoxList.get();
             AxisAlignedBB axisalignedbb = this.moveByPositionAndProgress(this.getMinMaxPiecesAABB(list));
             List<Entity> list1 = this.world.getEntitiesWithinAABBExcludingEntity((Entity)null, this.getMovementArea(axisalignedbb, enumfacing, d0).union(axisalignedbb));
 
@@ -134,7 +153,7 @@
 
                     if (entity.getPushReaction() != EnumPushReaction.IGNORE)
                     {
-                        if (flag)
+                        if (flag && !CreativeNoClipHelper.canEntityIgnoreClip(entity))  // Carpet creativeNoClip
                         {
                             switch (enumfacing.getAxis())
                             {
@@ -170,14 +189,25 @@
                         if (!(d1 <= 0.0D))
                         {
                             d1 = Math.min(d1, d0) + 0.01D;
-                            MOVING_ENTITY.set(enumfacing);
-                            entity.move(MoverType.PISTON, d1 * (double)enumfacing.getXOffset(), d1 * (double)enumfacing.getYOffset(), d1 * (double)enumfacing.getZOffset());
-                            MOVING_ENTITY.set((EnumFacing)null);
 
+                            if (!CreativeNoClipHelper.canEntityIgnoreClip(entity))  // Carpet creativeNoClip
+                            {
+                                MOVING_ENTITY.set(enumfacing);
+                                entity.move(MoverType.PISTON, d1 * (double) enumfacing.getXOffset(), d1 * (double) enumfacing.getYOffset(), d1 * (double) enumfacing.getZOffset());
+                                MOVING_ENTITY.set((EnumFacing) null);
+                            }
+
                             if (!this.extending && this.shouldHeadBeRendered)
                             {
                                 this.fixEntityWithinPistonBase(entity, enumfacing, d0);
                             }
+
+                            // [CM] Added UnloadedEntityFix
+                            if (CarpetSettings.unloadedEntityFix)
+                            {
+                                world.tickEntity(entity, false);
+                            }
+                            // [CM] End
                         }
                     }
                 }
@@ -270,9 +300,12 @@
             if (Math.abs(d0 - d1) < 0.01D)
             {
                 d0 = Math.min(d0, p_190605_3_) + 0.01D;
-                MOVING_ENTITY.set(p_190605_2_);
-                p_190605_1_.move(MoverType.PISTON, d0 * (double)enumfacing.getXOffset(), d0 * (double)enumfacing.getYOffset(), d0 * (double)enumfacing.getZOffset());
-                MOVING_ENTITY.set((EnumFacing)null);
+                if (!CreativeNoClipHelper.canEntityIgnoreClip(p_190605_1_))  // Carpet creativeNoClip
+                {
+                    MOVING_ENTITY.set(p_190605_2_);
+                    p_190605_1_.move(MoverType.PISTON, d0 * (double) enumfacing.getXOffset(), d0 * (double) enumfacing.getYOffset(), d0 * (double) enumfacing.getZOffset());
+                    MOVING_ENTITY.set((EnumFacing) null);
+                }
             }
         }
     }
@@ -319,9 +352,38 @@
                     iblockstate = Block.getValidBlockForPosition(this.pistonState, this.world, this.pos);
                 }
 
-                this.world.setBlockState(this.pos, iblockstate, 3);
-                this.world.neighborChanged(this.pos, iblockstate.getBlock(), this.pos);
+                // [CM] Movable TE's CARPET-DeadlyMC
+                if (!CarpetSettings.movableTileEntities)
+                {
+                    this.world.setBlockState(this.pos, iblockstate, 3);
+                    this.world.neighborChanged(this.pos, iblockstate.getBlock(), this.pos);
+                }
+                else
+                {
+                    this.placeBlock(iblockstate);
+                }
             }
+            // [CM] Movable TE's CARPET-DeadlyMC
+            // comment from fabric-carpet:
+            //     Handle TNT Explosions or other ways the moving Block is broken
+            //     Also /setblock will cause this to be called, and drop e.g. a moving chest's contents.
+            //     This is MC-40380 (BlockEntities that aren't Inventories drop stuff when setblock is called )
+            else if (CarpetSettings.movableTileEntities)
+            {
+                IBlockState iblockstate;
+                if (this.shouldHeadBeRendered)
+                {
+                    iblockstate = Blocks.AIR.getDefaultState();
+                }
+                else
+                {
+                    iblockstate = Block.getValidBlockForPosition(this.pistonState, this.world, this.pos);
+                }
+                if (this.carriedTileEntity != null && this.world.getBlockState(this.pos).getBlock() == Blocks.AIR) {
+                    this.placeBlock(iblockstate);  // qwq
+                    this.world.removeBlock(this.pos);
+                }
+            }
         }
     }
 
@@ -351,8 +413,15 @@
                         iblockstate = iblockstate.with(BlockStateProperties.WATERLOGGED, Boolean.valueOf(false));
                     }
 
-                    this.world.setBlockState(this.pos, iblockstate, 67);
-                    this.world.neighborChanged(this.pos, iblockstate.getBlock(), this.pos);
+                    if (!CarpetSettings.movableTileEntities)
+                    {
+                        this.world.setBlockState(this.pos, iblockstate, 67);
+                        this.world.neighborChanged(this.pos, iblockstate.getBlock(), this.pos);
+                    }
+                    else
+                    {
+                        this.placeBlock(iblockstate);
+                    }
                 }
             }
         }
@@ -378,6 +447,18 @@
         this.lastProgress = this.progress;
         this.extending = compound.getBoolean("extending");
         this.shouldHeadBeRendered = compound.getBoolean("source");
+    
+        // [CM] Movable TE's CARPET-DeadlyMC
+        if(CarpetSettings.movableTileEntities && compound.contains("carriedTileEntityCM", 10))
+        {
+            if(this.pistonState.getBlock() instanceof ITileEntityProvider)
+                this.carriedTileEntity = ((ITileEntityProvider)(this.pistonState.getBlock())).createNewTileEntity(this.world);
+            if(carriedTileEntity != null) // Can actually be null, as BlockPistonMoving.createNewTileEntity(...) returns null
+                this.carriedTileEntity.read(compound.getCompound("carriedTileEntityCM"));
+        }
+
+        // Cache BoundingBoxList creation
+        this.createVoxelShapeBoundingBoxListCache();
     }
 
     public NBTTagCompound write(NBTTagCompound compound)
@@ -388,6 +469,13 @@
         compound.putFloat("progress", this.lastProgress);
         compound.putBoolean("extending", this.extending);
         compound.putBoolean("source", this.shouldHeadBeRendered);
+    
+        // [CM] Movable TE's CARPET-DeadlyMC
+        if(CarpetSettings.movableTileEntities && this.carriedTileEntity != null)
+        {
+            compound.put("carriedTileEntityCM", this.carriedTileEntity.write(new NBTTagCompound()));
+        }
+        
         return compound;
     }
 
@@ -435,4 +523,37 @@
     {
         return this.lastTicked;
     }
+    
+    // [CM] Movable TE's - helper method
+    public void setCarriedTileEntity(TileEntity tileEntity)
+    {
+        this.carriedTileEntity = tileEntity;
+    }
+    
+    // [CM] Movable TE's - helper method
+    private void placeBlock(IBlockState targetState)
+    {
+        this.world.setBlockState(this.pos, targetState, 18); //Flag 18 => No block updates, TileEntity has to be placed first
+        
+        if(!this.world.isRemote)
+        {
+            if(carriedTileEntity != null)
+            {
+                this.world.removeTileEntity(this.pos);
+                carriedTileEntity.validate();
+                this.world.setTileEntity(this.pos, carriedTileEntity);
+            }
+            
+            //Update neighbors, comparators and observers now (same order as setBlockState would have if flag was set to 3 (default))
+            //This should not change piston behavior for vanilla-pushable blocks at all
+            
+            this.world.notifyNeighbors(pos, Blocks.MOVING_PISTON);
+            if (targetState.hasComparatorInputOverride())
+            {
+                this.world.updateComparatorOutputLevel(pos, targetState.getBlock());
+            }
+            this.world.notifyNeighborsOfStateChange(pos, targetState.getBlock());
+        }
+        this.world.neighborChanged(this.pos, targetState.getBlock(), this.pos);
+    }
 }
